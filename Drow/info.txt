вам нельзя редактировать модули которые вы подключаите в папку libs. пока программа запущенна она будет читат эти библиотеки в нужное время. ваш модуль не может иметь имя lib.py,  дело в том что при малйешей попытке указать не то имя проограмма попытается заругзить а lib.py модуль и импортировать его

также кроме функций документации info и help  вы можите создать функцию error эта функция нужна в том случае если ваша программа даст сбой и вы бы не хотели себя ограничивать, функция может принимать в параметр значение которое вернула ваша программа, а если не смогла то тогда текст "error 1"

я из тех людей, который если не смог запустить код, то могу поверить в то что код не нужен или так себе в оправдание и бросить дело до конца чтобы запустить и понять нужен ли мне, то ли это что я искал... Сейчас если у вс чтото не будет работать я бы хотел помочь, вдруг это реально годное, если же нет то я хочу зннат мнение каждого, критикику и прочие хочу чтобы проект развивался...

весь код пишем в отдельных библиотеках, первое слово это их имя.
при выборе конертного кода мы вызываем функцию даем ей имя файла, копируем содержимое в файл lib.py
импортируем lib файл и вызываем его функцию main(также будут функции и лргие, И файл - документация)
ВЫЗЫВАЯ ФУНКЦИЮ MAIN МЫ ОТДАЕМ ЕЙ ПАРАМЕТРЫ...

о модулях: обьязательно нужно иметь 3 функции help info main, если ваш код функций ваще не имеет можете в начале кода сздать их путсиыми.
имя файла до .ру должен совпадать с именем который вывводите..., имя модуля нельзя начинать на точку, это имена только внутренних пакетов - функционал внутри кода.
src -f in.txt; - переменная как правило для ссилки
;переменнные вскоре добавим. которые будут писаться начиная с символ долар.
write -v "Hello" ;-v variable -a address 
$src -v in.txt
write -v "Hello, World" -a in.txt -endline; - в файле будет Hello, World\n
update -v "!" -a in.txt; - в файле будет Hello, World!
var "txt"; - переменная как праивло ее используют чтобы набрать много текста и после слить в файл...
if (): - как правило туда ставлят можно ли редачить или читать, а также пустой ли файл или равен лли этому... но это только началоъ
for (): - как праивло используется на пару с переменнй и ветвлением или без ветвления для пеовтора крч записи или чтения с файла
#~/projects/Terminal.beta   [user set new open del]
.user -name root -pasword !auto_pasword -lang EN -no_auto_pasword;-auto_pasword or -no_auto_pasword, -default
set -if_file_null_other; -if_file_null_creat or -if_file_null_check
set -if_no_write_file_rename; or -if_no_write_file_try_again or -if_no_write_file_other
format -must_not_be "";
format -have_not_be "";
format -if_must_be_change_value "";
format -if_have_be_change_value "";
read -address "t.txt" -var tmp1
open -read -write -; -r -w -rw...
;set -set address ;де розшташована утилита.
.info user
.help
.quit
;#/\это все коментарии



if
 checkf -a in.txt
==
 cutf -a in.txt


  delf  clearf
;"" - кавычки не обьязательны но нужны для сохранения пустого текста а также текста с пробелами и некоторыми символами.
;() - скобки не обьязательны, но нужны для сохранения масива, пока что это не разрешается, но будет в have_not_be и must_not_be. пример: format -must_not_be ("", ""); в других если такое и будет, то только для того чтобы сохранить последний переззапсывая предедущие.... насчот скобок их можно будет испоьзовать и в реад.










# Console Terminal (alfa)
На данный момент код в разработке...<br>
Первый проект - попытка написать терминал.<br>
Терминал который может работать с файлами в консольном НО удобном режиме.


# _У этого терминала есть такие принципы:_
Если файл или модуль предназначен только для чтения, то он должен находится в<br>
 папке read, на которую терминал себе сам наложил ограничения флага -r.

Если файл или модуль предназначен только для редактирования, то он должен<br>
 находится в папке write, на которую терминал себе сам наложил ограничения<br>
 флагом -w.

Если файл не подходит под предедущие описания, то он должен находится в папке<br>
 work, на которую терминал себе сам наложил ограничения флага -rw.


# _Итог принципов такой:_
Есть файлы или модули которые нельзя редактировать,  которые нельзя читать и<br>
 которые для работы...


# _О некоторых папках:_
/read -r папка с которой принято только читать файлы.

/write -w папка в которую принято только записывать файлы.

/work или /temp -rw папка для временных файлов терминала.

/read/libs -r модули терминала.


# _О модулях:_
Модуль - библиотека на python, которая в некоторых вещах имеет свои<br> 
 ограничения.

1. Не волнуйтесь вы сможите написать и подключить и свои модули без усложнений.

2. Имя файла до разширения должно совпадать с именем вызова в терминале!

3. Модули должны хранится по не полному адрессу: read/libs/

4. Модули импортируються через файл lib.py - который содержит копию фашего<br>
 модуля, и если вы запустите одну и ту же команду, то вместо снова<br>
 скоипровать терминал сделает импортацию сразу.


# _Модуль обьязан иметь такие функции:_
main_m - исполняется при обращению к модулю. Принимает масив подобно args.<br>
error_m - Запускаем эту функцию, если main_m дал ошибку. Принимает масив<br>
 подобно args.<br>
info_m - выводит свой список команд (строки в пределах 80 char).<br>
help_m - выводит свою __doc__ (строки в пределах 80 char).<br>


# _Важно знать:_
"" - в строках можно опускать если в них нет пробелов.<br>
-а - в модуле write по умолчанию является активным ключом, так что можно<br>
 опускать если первым параментром хотите указать имя файла.<br>
-v - в модуле write по умолчанию является активным вторым ключом, так что<br>
можно опускать если первым параментром хотите указать имя файла.<br>
Имена файлов, модулей нельзя начинать с символов:  -  .  " (исправить<br> 
 так:  /. /" /- )<br>
Например: <b>write -a "in.txt" -v "Hello, World"</b><br>
или <b>write in.txt -v "Hello, World"</b><br>
или <b>write in.txt "Hello, World"</b>
 

# _Шаблон модуля:_
read/libs/pattern.py - это шаблон модуля, этот файл будет соотвецтвовать<br>
 требованиям всех нововедений, так-что при работе с новыми версиями у вас<br>
 уже будет миниум один пример.<br>
Пример работы с pattern.py как модулем:<br>
Пример: <b>pattern -a text_random</b><br>
Шаблон приймет эти два аргумента но не обработает, поэтому ничего не<br>
 произойдет.


Cut:
.переменстить файл
.сохранить имя.
.переименоать в либ.
 .при переподключении к другому модулю:
  .переметстить назад и вернуть имя.
  .начать с нулевого пункта.
 .при подключении к тому же самому модулю:
  .ничего не менять.
.подключить модуль.

юзеры имеют каждый свои настройки
также юзера можно привязать к языку, чтобы был дотсуп только в языке, такие юзеры различными версиями юзера(просто в каждом языке вы можите мсделать свои отдельные настройки юзеру, они называються шаблонные настройки) Сначала юзер импортирует настройки свои, а дальше испортирует себе настройки из языка изменяя те что ужеесть.

























